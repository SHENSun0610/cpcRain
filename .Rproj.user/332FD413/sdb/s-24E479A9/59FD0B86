{
    "collab_server" : "",
    "contents" : "#' Read in CPC Data from File\n#'\n#' This function allows you to query your customized NCDF files generated by cpcYearToNCDF in an efficient manner with minimal worrying\n#' about syntax. In order for these queries to work, you need to first download the relevant data using the \\code{cpcYearToNCDF} function\n#' for the years you wish to download. This function allows you to read those files, using the same \\code{download_folder} parameter.\n#' It can return either tidy data or a 3D array.\n#' @param start_date the first date of data to extract. Must be a date class object: see \\code{lubridate::ymd} for easy generation.\n#' @param end_date the last date of data to extract.\n#' @param lat_lims a vector of length 2 specifying the minimum and maximum latitudes to query\n#' @param lon_lims a vector of length 2 specifying the minimum and maximum longitudes to query\n#' @param download_folder the folder containing the \\code{.nc} files you wish to read. Should be the same as the \\code{download_folder} argument you passed to\n#'   \\code{cpcYearToNCDF} unless you have moved the files.\n#' @param tidy if TRUE, returns the data as a tidy \\code{data.table}. If FALSE, returns a 3D array indexed by [lon, lat, time].\n#' @param round_lonlat if TRUE, the longitude and latitude limits you enter will be rounded to the nearest valid values. If FALSE, if the values you enter are not\n#'   in the data set, this function will throw an error.\n#' @return returns either a \\code{data.table} with columns date, lon, lat, and prcp_mm or a three-dimensional array indexed [lon, lat, time]. This choice\n#'   is controlled by the \\code{tidy} argument.\n#' @import magrittr\n#' @import data.table\n#' @export cpcReadNCDF\ncpcReadNCDF <- function(start_date, end_date, lat_lims, lon_lims, download_folder = getwd(), tidy = T, round_lonlat = TRUE){\n  require(lubridate)\n  require(ncdf4)\n  require(magrittr)\n  require(data.table)\n\n  # ---------- Checks on the Parameters ------\n\n  # check the dates\n  if(!(is_date(start_date) & is_date(end_date))) stop('start_date and end_date must be date objects. see lubridate package for easy generation')\n\n  # check lims\n  if(!(length(lat_lims == 2) & length(lon_lims == 2))) stop('lat_lims and lon_lims must be length 2')\n  if(!(min(lat_lims) >= -90 | max(lat_lims) <= 90)) stop('lat_lims must be between -90 and 90')\n  if(!(min(lon_lims) >= 0 | max(lat_lims) <= 360)) stop('lon_lims must be between 0 and 360')\n\n  # check download_folder validity\n  if(substr(download_folder, nchar(download_folder), nchar(download_folder)) != '/') download_folder <- paste0(download_folder, '/')\n  if(!dir.exists(download_folder)) stop('invalid download_folder specified')\n\n  # check if years are available\n  years_requested <- year(start_date):year(end_date)\n  years_available <- unlist(strsplit(Sys.glob(paste0(download_folder, '*.nc')), '.nc'))\n  years_available <- substr(years_available, nchar(years_available) - 3, nchar(years_available)) %>% as.numeric()\n  if(!all(years_requested %in% years_available)) stop('Not all years requested are available. Use cpcYearToNCDF to download them first.')\n\n  # global parameters\n  global <- cpcGlobal()\n  lons <- global$cpcLonVec\n  lats <- global$cpcLatVec\n  # times depend on year\n\n  # set to nearest grids\n  if(!all(lat_lims %in% lats)){\n    if(round_lonlat){\n      warning('Adjusting lat_lims to nearest grid point')\n      lat_lims[1] <- lats[which.min(abs(lats - lat_lims[1]))]\n      lat_lims[2] <- lats[which.min(abs(lats - lat_lims[2]))]\n    } else{\n      stop('Invalid lat_lims parameter.')\n    }\n  }\n  if(!all(lon_lims %in% lons)){\n    if(round_lonlat){\n      warning('Adjusting lon_lims to nearest grid point')\n      lon_lims[1] <- lons[which.min(abs(lons - lon_lims[1]))]\n      lon_lims[2] <- lons[which.min(abs(lons - lon_lims[2]))]\n    } else {\n      stop('Invalid lon_lims parameter')\n    }\n  }\n\n  # ---------- Read the Data ------\n\n  # initialize\n  out_list <- vector('list', length(years_requested))\n\n  # loop through each year separately\n  for(i in 1:length(years_requested)){\n\n    # times depend on the year\n    times <- seq(ymd(paste(years_requested[i], 1, 1)), ymd(paste(years_requested[i], 12, 31)), 1) %>% as.numeric()\n\n    # set the start and end dates for this particular year\n    if(i == 1){ #it's first year\n      start_date_i <- start_date\n    } else {\n      start_date_i <- ymd(paste(years_requested[i], 1, 1))\n    }\n    if(i == length(years_requested)){ #it's first year\n      end_date_i <- end_date\n    } else {\n      end_date_i <- ymd(paste(year, 12, 31))\n    }\n\n    year_i <- years_requested[i]\n    nc_fn_i <- paste0(download_folder, 'cpcRain_', year_i, '.nc')\n\n    # build the start and count indices\n    start <- c(which(lons == min(lon_lims)),\n               which(lats == min(lat_lims)),\n               min(which(as_date(times) == start_date_i)))\n    end <- c(which(lons == max(lon_lims)),\n             which(lats == max(lat_lims)),\n             max(which(as_date(times) == end_date_i)))\n    count <- end - start + 1\n\n    nc <- nc_open(nc_fn_i)\n\n    nc_array <- ncvar_get(nc, varid = 'precip', start = start, count = count)\n    dimnames(nc_array)[[1]] <- lons[start[1]:end[1]]\n    dimnames(nc_array)[[2]] <- lats[start[2]:end[2]]\n    dimnames(nc_array)[[3]] <- times[start[3]:end[3]] %>% lubridate::as_date() %>% as.character()\n\n    # tidy data if tidy == TRUE else leave as array\n    if(tidy){\n      out_list[[i]] <- cpcMeltArray(nc_array)\n    } else {\n      out_list[[i]] <- nc_array\n    }\n\n  }\n\n  # join the data sets\n  if(tidy){\n    out_list <- rbindlist(out_list)\n  } else {\n    out_list <- abind::abind(out_list, along = 3)\n  }\n\n  return(out_list)\n}\n",
    "created" : 1467040439082.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3141460203",
    "id" : "59FD0B86",
    "lastKnownWriteTime" : 1467049159,
    "last_content_update" : 1467049159133,
    "path" : "~/Documents/Projects/cpcRain/R/cpcReadNCDF.R",
    "project_path" : "R/cpcReadNCDF.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}