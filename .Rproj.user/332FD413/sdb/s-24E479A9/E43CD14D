{
    "collab_server" : "",
    "contents" : "#' Access CPC Data for a Short Date Range\n#'\n#' This function provides access to CPC data for a date range.\n#' This function is intended to be called directly.\n#' For each date in the date range, it downloads the raw files, reads them to an array,\n#' and deletes the raw files.\n#' By default it returns a tidy data.table, but it can also return a 3D array.\n#' @param start_date the first data to download. Must be a date object -- see \\code{lubridate} package for easy creation of date objects\n#'   with the \\code{lubridate::ymd()} function.\n#' @param end_date as with \\code{start_date}, must be a date object.\n#' @param tidy if TRUE, the output data will be a tidy data.table with columns lon, lat, and prcp_mm.\n#'   if FALSE, the output data will be a 3D array with indices [lon, lat, time]\n#' @return returns a list with two entries: download_success and precip_data.\n#'   download_success is a data.frame with columns date and success, which define whether data was successfully downloaded for\n#'   each date in the range \\code{seq(start_date, end_date, 1)}.\n#'   precip_data is a 3D array if tidy is FALSE and a data.table if tidy is TRUE.\n#' @import data.table\n#' @import magrittr\n#' @export cpcQueryDateRange\ncpcQueryDateRange <- function(start_date, end_date, tidy = TRUE){\n\n  require(lubridate)\n\n  if(!lubridate::is.Date(start_date) | !lubridate::is.Date(end_date))\n    stop('date must be a R date object.See lubridate package for an easy way to accomplish this.')\n  if(!(year(start_date) %in% 1976:year(Sys.Date()) & year(end_date) %in% 1976:year(Sys.Date())))\n    stop('data range must be from 1976 to present')\n\n  # global values\n  param <- cpcGlobal()\n\n  # create a folder to download temporary data in\n  download_folder <- paste0(getwd(), '/tmp_cpc_folder')\n  dir.create(download_folder)\n\n  # all dates\n  all_dates <- seq(start_date, end_date, 1)\n\n  # track which days were successfully downloaded\n  all_date_success <- rep(NA, length(all_dates))\n\n  # Download the Raw Data\n  for(i in 1:length(all_dates)){\n\n    date_i <- all_dates[i]\n    all_date_success[i] <- cpcDownloadOneDay(date = date_i, download_folder = download_folder)\n\n  }\n\n  download_success_df <- data.frame(date = all_dates, success = all_date_success)\n\n\n  # Read in the Data\n\n  # first initialize array\n  lons <- param$cpcLonVec\n  lats <- param$cpcLatVec\n  times <- as.character(seq(start_date, end_date, 1))\n  array <- array(dim = c(length(lons), length(lats), length(times)),\n                 dimnames = list(lons, lats, times))\n  # accessed by [lat, lon, time]\n\n  # For each day of the year: (1) download raw file (2) read raw file (3) save to memory\n  for(i in 1:length(all_dates)){\n\n    date_i <- all_dates[i]\n    array[, , i] <- cpcReadRawOneDay(date = date_i, download_folder = download_folder)\n  }\n\n  unlink(download_folder, recursive = T, force = T)\n\n\n\n  # return download success and the output\n  out <- list(download_success = download_success_df)\n\n  # if tidy data option is true, melt the array\n  if(tidy){\n    out$precip_data <- cpcMeltArray(array)\n  } else {\n    out$precip_data <- array\n  }\n\n  return(out)\n\n}\n",
    "created" : 1467030552307.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2379721955",
    "id" : "E43CD14D",
    "lastKnownWriteTime" : 1467049949,
    "last_content_update" : 1467049949550,
    "path" : "~/Documents/Projects/cpcRain/R/cpcQueryDateRange.R",
    "project_path" : "R/cpcQueryDateRange.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}